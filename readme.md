# Порівняння жадібного та динамічного алгоритму на прикладі розміну грошей

У цьому аналізі порівнюється ефективність двох алгоритмів розміну суми грошей на мінімальну кількість монет, а саме:

* Жадібний алгоритм
* Алгоритм динамічного програмування

Для порівняння використовувалися суми 113 коп. (мала сума) та 123456 коп. (велика сума).

## Результати

| Алгоритм | Мала сума | Велика сума |
| ------------- |:-------------:|:-------------:|
| Жадібний | 0.0000 мс | 0.0000 мс |
| Динамічне програмування | 0.0000 мс | 89.8921 мс |

**Мала сума (113 коп.):**

Жадібний алгоритм і динамічне програмування показали однаковий оптимальний результат:

- 50 коп. - 2 монети
- 10 коп. - 1 монета  
- 2 коп. - 1 монета
- 1 коп. - 1 монета

Час роботи обох алгоритмів для малої суми становив 0.0000 мс.

**Велика сума (123456 коп.):**

Жадібний алгоритм і динамічне програмування також показали однаковий оптимальний результат:

- 50 коп. - 2469 монет 
- 5 коп. - 1 монета
- 1 коп. - 1 монета

Однак час роботи алгоритмів сильно відрізнявся. Жадібний алгоритм виконався за 0.0000 мс, в той час як динамічне програмування - за 89.8921 мс.

*Примітка: при кожному запуску програми значення часу виконання можуть трохи відрізнятися, але суті це не змінює.*

## Висновки

* Для **малих сум** обидва алгоритми працюють однаково швидко і дають оптимальний результат.
* При **великих сумах** жадібний алгоритм працює набагато швидше за динамічне програмування.
* У цьому конкретному тесті для **великої суми** обидва алгоритми також показали **однаковий оптимальний результат**. Це може бути специфікою вхідних даних.
* Незважаючи на те, що обидва алгоритми показали оптимальний результат, загалом динамічне програмування **завжди гарантує оптимальний результат**, на відміну від жадібного алгоритму.

Отже, в реальних системах краще використовувати алгоритм **динамічного програмування** задля гарантовано оптимального розміну.  Хоча для дуже великих сум можна розглянути комбінацію підходів: спочатку застосувати швидкий жадібний алгоритм, а потім динамічне програмування до отриманого результату для оптимізації.